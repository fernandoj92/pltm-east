/* Generated By:JavaCC: Do not edit this line. BifParser.java */
package org.latlab.io.bif;

import java.awt.Color;
import java.awt.Point;
import java.util.ArrayList;
import java.util.List;

import org.latlab.io.AbstractParser;
import org.latlab.io.BeliefNodeProperty;
import org.latlab.io.Properties;
import org.latlab.io.BeliefNodeProperty.ConnectionConstraint;
import org.latlab.model.BayesNet;
import org.latlab.model.BeliefNode;
import org.latlab.model.CGPotential;
import org.latlab.model.ContinuousBeliefNode;
import org.latlab.model.DiscreteBeliefNode;
import org.latlab.util.ContinuousVariable;
import org.latlab.util.DiscreteVariable;
import org.latlab.util.Function;
import org.latlab.util.JointContinuousVariable;
import org.latlab.util.SingularContinuousVariable;
import org.latlab.util.Variable;

/**
 * A parser for BIF file.
 */
@SuppressWarnings("all")
public class BifParser extends AbstractParser implements BifParserConstants {
        public <T extends BayesNet> T parse(T network) throws org.latlab.io.ParseException {
                try {
                        properties = new Properties();
                        Network(network);
            return network;
                }
                catch (Throwable e) {
                        throw new org.latlab.io.ParseException(e);
                }
        }


        public Properties getProperties() {
                return properties;
        }

        private static int computeNumberOfCells(List<DiscreteVariable> variables) {
                if (variables.size() == 0)
                        return 0;

                int product = 1;
                for (DiscreteVariable v : variables) {
                        product *= v.getStates().size();
                }

                return product;
        }

        /**
	 * Holds the properties of the nodes and network.  
	 * Properties are stored separately because they are related to the 
	 * presentation part and are not stored in the model part.
	 */
        private Properties properties;

  final public void Network(BayesNet network) throws ParseException {
    NetworkDeclaration(network);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VARIABLE:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      VariableDeclaration(network);
    }
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PROBABILITY:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_2;
      }
      ProbabilityDeclaration(network);
    }
    jj_consume_token(0);
  }

  final public void NetworkDeclaration(BayesNet network) throws ParseException {
  String name = null;
    jj_consume_token(NETWORK);
    name = IdentifierValue();
    jj_consume_token(44);
    jj_consume_token(45);
                                                   network.setName(name);
  }

  final public void VariableDeclaration(BayesNet network) throws ParseException {
        String name;
        BeliefNode node = null;
    jj_consume_token(VARIABLE);
    name = IdentifierValue();
    jj_consume_token(44);
    node = VariableTypeDeclaration(network, name);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PROPERTY:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_3;
      }
      VariableProperty(node);
    }
    jj_consume_token(45);
  }

  final public void ProbabilityDeclaration(BayesNet network) throws ParseException {
        List<Variable> nodeVariables = new ArrayList<Variable>();
        List<Variable> parents = new ArrayList<Variable>();
        List<DiscreteVariable> discreteVariables;
        ContinuousBeliefNode continuousNode = null;
        DiscreteBeliefNode discreteNode = null;
        BeliefNode node;
        Function function = null;
        CGPotential potential = null;
        boolean discrete = true;
    jj_consume_token(PROBABILITY);
    jj_consume_token(46);
    VariablesInProbabilityDeclaration(network, nodeVariables, parents);
                        discreteVariables =
                                new ArrayList<DiscreteVariable>(
                                        nodeVariables.size() + parents.size());
                        Variable first = nodeVariables.get(0);
                        node = network.getNode(first);
                        if (node instanceof ContinuousBeliefNode) {
                                if (nodeVariables.size() > 1) {
                                        // combine the nodes of other variables to the first
                                        // node to form a composite node if necessary
                                        List<ContinuousBeliefNode> nodes =
                                                new ArrayList<ContinuousBeliefNode>(nodeVariables.size());

                                        for (int i = 0; i < nodeVariables.size(); i++) {
                                                nodes.add(network.getNode(
                                                        (ContinuousVariable) nodeVariables.get(i)));
                                        }

                                        node = network.combine(true, nodes);
                                        properties.combine((ContinuousBeliefNode) node, nodes);
                                }

                                continuousNode = (ContinuousBeliefNode) node;
                                discrete = false;
                        } else if (node instanceof DiscreteBeliefNode) {
                                discreteNode = (DiscreteBeliefNode) node;
                                discrete = true;

                                discreteVariables.add((DiscreteVariable) first);
                        } else {
                                String message = String.format(
                                        "The belief node %s has an unexpected type.",
                                        first.getName());
                                {if (true) throw new ParseException(message);}
                        }

                        // add the parents to the current node
                        for (Variable parent : parents) {
                                network.addEdge(node, network.getNode(parent.getName()));
                                discreteVariables.add((DiscreteVariable) parent);
                        }
    jj_consume_token(47);
    jj_consume_token(44);
    if (discrete) {
      function = DiscreteProbabilityDefinition(discreteVariables);
                          discreteNode.setCpt(function);
    } else {
      ;
    }
    if (!discrete) {
      potential = ContinuousProbabilityDefinition(continuousNode.getVariable(), discreteVariables);
                          continuousNode.setPotential(potential);
    } else {
      ;
    }
    jj_consume_token(45);
  }

/**
 * Parses the variables in the probability declaration.  The variables
 * after the {@code |} character are considered to be parent variables.
 * If the first variable is discrete, all the variables after that variable
 * are considered to be continuous.
 *
 * The parsed variables are put into the given list.  These lists should have
 * been constructed.
 */
  final public void VariablesInProbabilityDeclaration(BayesNet network, List<Variable> nodes, List<Variable> parents) throws ParseException {
        String nodeName;
        BeliefNode node;
        boolean isParent = false;
    nodeName = IdentifierValue();
                node = (BeliefNode) network.getNode(nodeName);
                if (node == null) {
                        String message = String.format(
                                "The variable %s indicated in probability definition is not found",
                                nodeName);
                        {if (true) throw new ParseException(message);}
                }
                nodes.add(node.getVariable());

                // the next variable must be a parent if the first one is a discrete
                // variable
                isParent = node.getVariable() instanceof DiscreteVariable;
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
      case 48:
      case 49:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_4;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 48:
      case 49:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 48:
          jj_consume_token(48);
          break;
        case 49:
          jj_consume_token(49);
                        isParent = true;
          break;
        default:
          jj_la1[4] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[5] = jj_gen;
        ;
      }
      nodeName = IdentifierValue();
                        node = (BeliefNode) network.getNode(nodeName);

                        // network.addEdge(node, parentNode);
                        if (isParent)
                                parents.add(node.getVariable());
                        else
                                nodes.add(node.getVariable());
    }
  }

/**
	Reads a probability definition for a given node.
	The first variable in the argument is the node variable, and the
	remaining variables (if exist) are the parent variables.
	The probabilities specified in the file depend on the order 
	of these variables.
*/
  final public Function DiscreteProbabilityDefinition(List<DiscreteVariable> variables) throws ParseException {
        double probability;
        Function function = Function.createFunction(variables);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TABLE:
      jj_consume_token(TABLE);
                int numberOfCells = computeNumberOfCells(variables);
                ArrayList<Double> cells = new ArrayList<Double>(numberOfCells);
      label_5:
      while (true) {
        probability = NonNegativeFloat();
                  cells.add(probability);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NON_NEGATIVE_FLOAT:
        case 53:
          ;
          break;
        default:
          jj_la1[6] = jj_gen;
          break label_5;
        }
      }
      jj_consume_token(50);
                function.setCells(variables, cells);
                {if (true) return function;}
      break;
    case 46:
      label_6:
      while (true) {
        jj_consume_token(46);
                        ArrayList<Integer> states =
                                new ArrayList<Integer>(variables.size());
                        states.add(0);  // start the child state from zero
                        int stateIndex;
        label_7:
        while (true) {
          // the states.size() indicate the index of the next parent
                                  stateIndex = State(variables.get(states.size()));
                                states.add(stateIndex);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENTIFIER:
            ;
            break;
          default:
            jj_la1[7] = jj_gen;
            break label_7;
          }
        }
        jj_consume_token(47);
                        if (states.size() != variables.size())
                                {if (true) throw new ParseException(
                                        String.format(
                                                "The parent states of variable %s are not completed specified.",
                                                variables.get(0).getName()));}
        label_8:
        while (true) {
          probability = NonNegativeFloat();
                                function.setCell(variables, states, probability);
                                states.set(0, states.get(0) + 1);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case NON_NEGATIVE_FLOAT:
          case 53:
            ;
            break;
          default:
            jj_la1[8] = jj_gen;
            break label_8;
          }
        }
                        if (states.get(0) != variables.get(0).getStates().size())
                                {if (true) throw new ParseException(
                                        String.format("The probabilities of the variable %s are not specified for all of the states.",
                                                variables.get(0).getName()));}
        jj_consume_token(50);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 46:
          ;
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_6;
        }
      }
          {if (true) return function;}
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
	Reads a probability definition for a given node.
	The first variable in the argument is the node variable, and the
	remaining variables (if exist) are the parent variables.
	The probabilities specified in the file depend on the order 
	of these variables.
*/
  final public CGPotential ContinuousProbabilityDefinition(JointContinuousVariable joint, List<DiscreteVariable> parents) throws ParseException {
        double entry;


        if (parents.size() > 1) {
                String message = String.format(
                        "It currently does not support a continuous variable to have more than one parent, " +
                        "while the continuous variable %s has more than one parents: %s",
                        joint.getName(), parents.toString());
                throw new ParseException(message);
        }

        DiscreteVariable parent = parents.size() == 0? null : parents.get(0);
        CGPotential potential = new CGPotential(joint, parent);
        int expectedSize;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TABLE:
      jj_consume_token(TABLE);
                expectedSize = potential.expectedNumberOfEntries();
                List<Double> entries = new ArrayList<Double>(expectedSize);
      label_9:
      while (true) {
        entry = RealNumber();
                  entries.add(entry);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NON_NEGATIVE_INTEGER:
        case NON_NEGATIVE_FLOAT:
        case NEGATIVE_FLOAT:
        case 53:
          ;
          break;
        default:
          jj_la1[11] = jj_gen;
          break label_9;
        }
      }
      jj_consume_token(50);
                if (entries.size() != expectedSize) {
                        String message = String.format(
                                "The table entries of %s | %s do not have the correct number.",
                                joint.getName(), parents.toString());
                        {if (true) throw new ParseException(message);}
                }
                potential.setEntries(parents, entries);
                {if (true) return potential;}
      break;
    case 46:
      label_10:
      while (true) {
                        int stateIndex;
                        expectedSize = potential.expectedNumberOfEntriesPerConfig();
                        entries = new ArrayList<Double>(expectedSize);
                        List<Integer> states = new ArrayList<Integer>(parents.size());
        jj_consume_token(46);
                        entries.clear();
                        states.clear();
        label_11:
        while (true) {
          // the states.size() indicate the index of the next parent
                                  stateIndex = State(parents.get(states.size()));
                                if (stateIndex < 0) {
                                        String message = String.format(
                                                "The probability definition of variable %s includes a" +
                                                        " state not found in its parent variable %s.",
                                                joint.getName(), parents.toString());
                                        {if (true) throw new ParseException(message);}
                                }

                                states.add(stateIndex);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENTIFIER:
            ;
            break;
          default:
            jj_la1[12] = jj_gen;
            break label_11;
          }
        }
        jj_consume_token(47);
                        if (states.size() != parents.size()) {
                                String message = String.format(
                                        "The parent states of %s | %s are not completely specified.",
                                        joint.getName(), parents.toString());
                                {if (true) throw new ParseException(message);}
                        }
        label_12:
        while (true) {
          entry = RealNumber();
                                entries.add(entry);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case NON_NEGATIVE_INTEGER:
          case NON_NEGATIVE_FLOAT:
          case NEGATIVE_FLOAT:
          case 53:
            ;
            break;
          default:
            jj_la1[13] = jj_gen;
            break label_12;
          }
        }
                        if (entries.size() != expectedSize) {
                                String message = String.format(
                                        "The entries of %s | %s do not have the correct number.",
                                        joint.getName(), parents.toString());
                                {if (true) throw new ParseException(message);}
                        }
                        potential.setEntries(parents, states, entries);
        jj_consume_token(50);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 46:
          ;
          break;
        default:
          jj_la1[14] = jj_gen;
          break label_10;
        }
      }
          {if (true) return potential;}
      break;
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public BeliefNode VariableTypeDeclaration(BayesNet network, String name) throws ParseException {
        List<String> states;
        BeliefNode node;
    jj_consume_token(TYPE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DISCRETE:
      states = DiscreteVariableStatesDeclaration();
                node = network.addNode(new DiscreteVariable(name, states));
                {if (true) return node;}
      break;
    case CONTINUOUS:
      ContinuousVariableDeclaration();
                node = network.addNode(new SingularContinuousVariable(name));
                {if (true) return node;}
      break;
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public ArrayList<String> DiscreteVariableStatesDeclaration() throws ParseException {
        int numberOfStates;
        String state;
        ArrayList<String> states;
    jj_consume_token(DISCRETE);
    jj_consume_token(51);
    numberOfStates = NonNegativeInteger();
    jj_consume_token(52);
                  states = new ArrayList<String>(numberOfStates);
    jj_consume_token(44);
    label_13:
    while (true) {
      state = IdentifierValue();
                                       states.add(state);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 48:
        jj_consume_token(48);
        break;
      default:
        jj_la1[17] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[18] = jj_gen;
        break label_13;
      }
    }
    jj_consume_token(45);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 50:
      jj_consume_token(50);
      break;
    default:
      jj_la1[19] = jj_gen;
      ;
    }
                if (numberOfStates != states.size()) {
                        String message = String.format(
                                "The number of states { %s } (%d)" +
                                        " does not match that declared (%d).",
                                states.toString(), states.size(), numberOfStates);
                        {if (true) throw new ParseException(message);}
                }
                {if (true) return states;}
    throw new Error("Missing return statement in function");
  }

  final public void ContinuousVariableDeclaration() throws ParseException {
    jj_consume_token(CONTINUOUS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 50:
      jj_consume_token(50);
      break;
    default:
      jj_la1[20] = jj_gen;
      ;
    }
  }

  final public void VariableProperty(BeliefNode node) throws ParseException {
  BeliefNodeProperty property = properties.getBeliefNodeProperty(node);
    jj_consume_token(PROPERTY);
    VariablePropertyString(property);
    jj_consume_token(PROPERTY_END_CHAR);
  }

// Reads a property string from the input and put it into the property object.  final public void VariablePropertyString(BeliefNodeProperty property) throws ParseException {
        int x;
        int y;
        int angle;
        BeliefNodeProperty.FrameType frame;
        String text;
        Color color;
    jj_consume_token(PROPERTY_DOUBLE_QUOTE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case POSITION:
      jj_consume_token(POSITION);
      jj_consume_token(PROPERTY_EQUAL);
      jj_consume_token(PROPERTY_LPARENTHESE);
      x = NonNegativeInteger();
      jj_consume_token(PROPERTY_COMMA);
      y = NonNegativeInteger();
      jj_consume_token(PROPERTY_RPARENTHESE);
                property.setPosition(new Point(x,y));
      break;
    case ROTATION:
      jj_consume_token(ROTATION);
      jj_consume_token(PROPERTY_EQUAL);
      angle = NonNegativeInteger();
                property.setRotation(angle);
      break;
    case FRAME:
      jj_consume_token(FRAME);
      jj_consume_token(PROPERTY_EQUAL);
      frame = FrameType();
                property.setFrame(frame);
      break;
    case LABEL:
      jj_consume_token(LABEL);
      jj_consume_token(PROPERTY_EQUAL);
      text = QuotedStringValue();
                property.setLabel(text);
      break;
    case FORECOLOR:
      jj_consume_token(FORECOLOR);
      jj_consume_token(PROPERTY_EQUAL);
      color = ColorValue();
                property.setForeColor(color);
      break;
    case BACKCOLOR:
      jj_consume_token(BACKCOLOR);
      jj_consume_token(PROPERTY_EQUAL);
      color = ColorValue();
                property.setBackColor(color);
      break;
    case LINECOLOR:
      jj_consume_token(LINECOLOR);
      jj_consume_token(PROPERTY_EQUAL);
      color = ColorValue();
                property.setLineColor(color);
      break;
    case FONT:
      jj_consume_token(FONT);
      jj_consume_token(PROPERTY_EQUAL);
      text = QuotedStringValue();
                property.setFontName(text);
      break;
    case FONTSIZE:
      jj_consume_token(FONTSIZE);
      jj_consume_token(PROPERTY_EQUAL);
      x = NonNegativeInteger();
                property.setFontSize(x);
      break;
    case CONNECTION_CONSTRAINT:
      jj_consume_token(CONNECTION_CONSTRAINT);
      jj_consume_token(PROPERTY_EQUAL);
      text = QuotedStringValue();
                property.setConnectionConstraint(
                        Enum.valueOf(ConnectionConstraint.class, text));
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(PROPERTY_DOUBLE_QUOTE);
  }

  final public String IdentifierValue() throws ParseException {
  Token t;
    t = jj_consume_token(IDENTIFIER);
                {if (true) return t.image.substring(1, t.image.length() - 1);}
    throw new Error("Missing return statement in function");
  }

  final public String QuotedStringValue() throws ParseException {
  Token t;
    t = jj_consume_token(SINGLE_QUOTED_STRING);
                // trim the quotes
                {if (true) return t.image.substring(1, t.image.length() - 1);}
    throw new Error("Missing return statement in function");
  }

  final public int State(DiscreteVariable variable) throws ParseException {
        String name;
    name = IdentifierValue();
                                 {if (true) return variable.indexOf(name);}
    throw new Error("Missing return statement in function");
  }

  final public int NonNegativeInteger() throws ParseException {
  Token t;
    t = jj_consume_token(NON_NEGATIVE_INTEGER);
                                   {if (true) return Integer.parseInt(t.image);}
    throw new Error("Missing return statement in function");
  }

  final public double NonNegativeFloat() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NON_NEGATIVE_FLOAT:
      t = jj_consume_token(NON_NEGATIVE_FLOAT);
                                 {if (true) return Double.parseDouble(t.image);}
      break;
    case 53:
      jj_consume_token(53);
            {if (true) return Double.NaN;}
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public double RealNumber() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NON_NEGATIVE_INTEGER:
    case NON_NEGATIVE_FLOAT:
    case NEGATIVE_FLOAT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NON_NEGATIVE_FLOAT:
        t = jj_consume_token(NON_NEGATIVE_FLOAT);
        break;
      case NEGATIVE_FLOAT:
        t = jj_consume_token(NEGATIVE_FLOAT);
        break;
      case NON_NEGATIVE_INTEGER:
        t = jj_consume_token(NON_NEGATIVE_INTEGER);
        break;
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                  {if (true) return Double.parseDouble(t.image);}
      break;
    case 53:
      jj_consume_token(53);
            {if (true) return Double.NaN;}
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public BeliefNodeProperty.FrameType FrameType() throws ParseException {
  BeliefNodeProperty.FrameType type;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NONE:
      jj_consume_token(NONE);
                 type = BeliefNodeProperty.FrameType.NONE;
      break;
    case OVAL:
      jj_consume_token(OVAL);
                 type = BeliefNodeProperty.FrameType.OVAL;
      break;
    case RECTANGLE:
      jj_consume_token(RECTANGLE);
                      type = BeliefNodeProperty.FrameType.RECTANGLE;
      break;
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          {if (true) return type;}
    throw new Error("Missing return statement in function");
  }

  final public Color ColorValue() throws ParseException {
  int r, g, b;
    jj_consume_token(PROPERTY_LPARENTHESE);
    r = NonNegativeInteger();
    jj_consume_token(PROPERTY_COMMA);
    g = NonNegativeInteger();
    jj_consume_token(PROPERTY_COMMA);
    b = NonNegativeInteger();
    jj_consume_token(PROPERTY_RPARENTHESE);
          {if (true) return new Color(r,g,b);}
    throw new Error("Missing return statement in function");
  }

  /** Generated Token Manager. */
  public BifParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[26];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x800,0x1000,0x40000,0x800000,0x0,0x0,0x200000,0x800000,0x200000,0x0,0x20000,0x700000,0x800000,0x700000,0x0,0x20000,0xc000,0x0,0x800000,0x0,0x0,0xfe000000,0x200000,0x700000,0x700000,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x30000,0x30000,0x30000,0x200000,0x0,0x200000,0x4000,0x4000,0x200000,0x0,0x200000,0x4000,0x4000,0x0,0x10000,0x0,0x40000,0x40000,0x7,0x200000,0x0,0x200000,0x38,};
   }

  /** Constructor with InputStream. */
  public BifParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public BifParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new BifParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public BifParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new BifParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public BifParser(BifParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(BifParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[54];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 26; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 54; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
