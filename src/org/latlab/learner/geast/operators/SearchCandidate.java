package org.latlab.learner.geast.operators;

import java.util.Comparator;

import org.latlab.learner.geast.EmFramework;
import org.latlab.learner.geast.Estimation;
import org.latlab.learner.geast.Focus;
import org.latlab.learner.geast.IModelWithScore;
import org.latlab.model.Gltm;
import org.latlab.util.DoubleComparator;
import org.latlab.util.Evaluator;

/**
 * Candidate generated by an implementation of {@link SearchOperator}.
 * 
 * <p>
 * It contains information about this search candidate for the GEAST algorithm.
 * Each search operator has its own subclass of {@link SearchCandidate}. The
 * constructors of its subclass usually accepts the changes made in the model by
 * the search operator and generates the resulting model and pass it to this
 * super class.
 * 
 * @author leonard
 * 
 */
public abstract class SearchCandidate {

	/**
	 * Compares the scores of two search candidates in descending order (and
	 * thus the negate operator). Valid only after {@link #evaluate(Evaluator)}
	 * has been called on the candidates.
	 */
	public static final Comparator<SearchCandidate> SCORE_COMPARATOR =
			new Comparator<SearchCandidate>() {
				public int compare(SearchCandidate o1, SearchCandidate o2) {
					return -DoubleComparator.compare(o1.score, o2.score);
				}
			};

	private IModelWithScore estimation;

	/**
	 * Holds the structure (without correct parameters) of the candidate model.
	 */
	protected final Gltm structure;

	/**
	 * The base model from which this candidate is generated.
	 */
	public final IModelWithScore base;

	/**
	 * Holds the variables that have been modified in the search candidate. This
	 * information can be utilized in the local EM.
	 */
	protected final Focus modification;

	/**
	 * The score of this search candidate.
	 */
	private double score = Double.NaN;

	/**
	 * Constructs this search candidate with a base estimation. Other member
	 * variables should be set properly at somewhere other than this
	 * constructor.
	 * 
	 * @param base
	 *            estimation this candidate is generated from
	 */
	protected SearchCandidate(IModelWithScore base) {
		this(base, base.model().clone(), null);
	}

	/**
	 * Constructs this search candidate with a base estimation and the structure
	 * of the model.
	 * 
	 * @param base
	 *            estimation this candidate is generated from
	 * @param structure
	 *            the structure of the candidate model generated
	 * @param estimation
	 *            estimation of this candidate, or {@code null}
	 */
	protected SearchCandidate(IModelWithScore base, Gltm structure,
			IModelWithScore estimation) {
		this.base = base;
		this.structure = structure;
		this.estimation = estimation;
		this.modification = new Focus();
	}

	public void estimate(EmFramework em) {
		Estimation result;

		if (estimation == null)
			result = em.estimate(structure, modification);
		else
			result = em.estimate(estimation, modification);

		// release the memory held by the search candidate, since there
		// may be a large number of search candidates
		result.complete();

		estimation = result;
	}

	public IModelWithScore estimation() {
		return estimation;
	}

	/**
	 * Evaluates this search candidate. It uses the given {@code em} to
	 * estimates the parameters and then uses the given {@code evaluator} to
	 * score this candidate.
	 * 
	 * @param em
	 *            for estimating parameters
	 * @param evaluator
	 *            for evaluation of this candidate
	 */
	public void evaluate(EmFramework em, Evaluator<SearchCandidate> evaluator) {
		estimate(em);
		score = evaluator.evaluate(this);
	}

	public double score() {
		return score;
	}

	/**
	 * Returns the model of this search candidate. When no estimation has been
	 * run on the structure model, the structure is returned.
	 * 
	 * @return model of this search candidate
	 */
	public Gltm model() {
		return estimation == null ? structure : estimation.model();
	}

	/**
	 * {@code true} if this is a new candidate, or {@code false} if this is a
	 * given candidate, which means the search operator fails to find a better
	 * candidate than the given base model.
	 * 
	 * @return whether this is a new candidate
	 */
	public boolean isNew() {
		return true;
	}

	public abstract String element();

	public abstract String attributes();

	public abstract String name();

	public abstract String operatorName();
	
	@Override
	public String toString() {
		return name() + " " + attributes();
	}
}
