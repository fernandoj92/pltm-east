package org.latlab.learner.geast.operators;

import java.util.List;
import java.util.concurrent.ExecutorCompletionService;

import org.latlab.learner.geast.EmFramework;
import org.latlab.learner.geast.IModelWithScore;
import org.latlab.learner.geast.context.Context;
import org.latlab.util.Evaluator;

/**
 * Search operator that perform candidate search in parallel using multiple
 * threads.
 * 
 * @author leonard
 * 
 */
public abstract class MultithreadSearchOperator extends SearchOperator {

	public MultithreadSearchOperator(Context context) {
		super(context);
	}

	/**
	 * Returns the {@code base} candidate if it can't find a better one. So it
	 * guarantees to return the best model (either the base model or a found
	 * better model).
	 * 
	 * @param base
	 *            base model to search from
	 * @return the best candidate it can find
	 */
	@Override
	public SearchCandidate search(IModelWithScore base,
			Evaluator<SearchCandidate> evaluator) {
		context.log().writeStartElementWithTime(name(), null);

		ExecutorCompletionService<SearchCandidate> ecs =
				new ExecutorCompletionService<SearchCandidate>(
						context.searchExecutor());

		List<SearchCandidate> candidates = generateCandidates(base);

		// estimates the candidates using an executor
		for (SearchCandidate candidate : candidates) {
			ecs.submit(getRunnableEvaluation(candidate, context.screeningEm(),
					evaluator), candidate);
		}

		// here screens the generated candidates by adding them to a queue with
		// bounded size
		ScreenQueue screenQueue = new ScreenQueue(context.screeningSize());
		for (int i = 0; i < candidates.size(); i++) {
			SearchCandidate candidate = null;
			try {
				candidate = ecs.take().get();
				screenQueue.add(candidate);
				log(candidate);
			} catch (Exception e) {
				context.log().write(e, candidate);
			}
		}

		// evaluate more carefully on the remaining candidates to select the
		// best one
		SearchCandidate best = new GivenCandidate(base);

		for (SearchCandidate candidate : screenQueue) {
			ecs.submit(getRunnableEvaluation(candidate, context.selectionEm(),
					evaluator), candidate);
		}

		for (int i = 0; i < screenQueue.size(); i++) {
			SearchCandidate candidate = null;
			try {
				candidate = ecs.take().get();

				// log the original model's name, so that it can be compared
				// with the candidates generated by the search operator.
				context.log().writeElement("selecting", candidate, true);

				// the BIC comparator is in descending order
				if (SearchCandidate.SCORE_COMPARATOR.compare(candidate, best) < 0)
					best = candidate;
			} catch (Exception e) {
				context.log().write(e, candidate);
			}
		}

		context.log().writeElement("completed", best, true);
		context.log().writeEndElement(name());

		return best;
	}

	/**
	 * Returns a runnable procedure that estimates this candidate using the
	 * given EM algorithm.
	 * 
	 * @param em
	 *            uses to estimate this candidate
	 * @return a runnable procedure
	 */
	public static Runnable getRunnableEvaluation(
			final SearchCandidate candidate, final EmFramework em,
			final Evaluator<SearchCandidate> evaluator) {
		return new Runnable() {
			public void run() {
				candidate.evaluate(em, evaluator);
			}
		};
	}

}
